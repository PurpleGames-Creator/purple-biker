<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ğŸŸ£purple bikerğŸŸ£</title>
  <meta name="apple-mobile-web-app-title" content="ğŸŸ£purple bikerğŸŸ£">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html:has(body.start-screen) {
      height: 100%;
      overflow: hidden;
      overscroll-behavior: none;
    }
    html, body {
      width: 100%;
      min-height: 100vh;
      height: 100vh;
      min-width: 100vw;
      overflow-x: hidden;
      overflow-y: auto;
      overscroll-behavior: none;
      touch-action: pan-y;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      background: radial-gradient(ellipse at top, #3a0ca3 0%, #1a1a2e 45%, #05010a 100%);
      background-size: 100vw 100vh;
      background-position: center;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', system-ui, sans-serif;
      color: #f5f0ff;
    }
    body:not(.start-screen) {
      background: radial-gradient(ellipse at top center, #050818 0%, #0d1530 35%, #1a1b3b 65%, #020008 100%);
      background-size: 100vw 100vh;
      background-position: center;
      background-repeat: no-repeat;
    }
    body.start-screen {
      height: 100vh;
      min-height: 100vh;
      overflow: hidden;
      overscroll-behavior: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }

    #bgStarsCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      display: none;
    }
    body:not(.start-screen) #bgStarsCanvas {
      display: block;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image:
        radial-gradient(circle at top, rgba(186, 104, 255, 0.22) 0, transparent 55%),
        repeating-linear-gradient(
          to bottom,
          rgba(120, 80, 255, 0.4) 0,
          rgba(120, 80, 255, 0.4) 1px,
          transparent 1px,
          transparent 28px
        ),
        repeating-linear-gradient(
          to right,
          rgba(120, 80, 255, 0.4) 0,
          rgba(120, 80, 255, 0.4) 1px,
          transparent 1px,
          transparent 28px
        );
      opacity: 0.3;
      transform-origin: bottom center;
      transform: perspective(700px) rotateX(65deg) translateY(40px);
      animation: gridScroll 18s linear infinite;
      pointer-events: none;
      z-index: -1;
    }
    #gameContainer {
      position: relative;
      z-index: 1;
      max-width: 100vw;
      height: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      user-select: none;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      max-width: 800px;
      height: auto;
      max-height: 100vh;
      aspect-ratio: 800 / 450;
      touch-action: none;
      user-select: none;
      -webkit-touch-callout: none;
      background: transparent !important;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    #uiOverlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
    }
    body.start-screen #uiOverlay {
      position: relative;
      top: auto; left: auto; right: auto; bottom: auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
    }
    body.start-screen #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      min-height: 100vh;
      width: 100%;
      overflow: hidden;
    }
    body.start-screen #gameCanvas {
      display: none !important;
    }
    #uiOverlay > * { pointer-events: auto; }
    #scoreDisplay {
      display: none;
      position: absolute;
      top: min(12px, 3vh);
      left: 50%;
      transform: translateX(-50%);
      color: #e94560;
      font-size: clamp(18px, 4.8vw, 32px);
      font-weight: 700;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      letter-spacing: 0.05em;
    }
    #startScreen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      width: 100%;
      max-width: 100%;
      height: 100%;
      padding: max(60px, env(safe-area-inset-top)) 16px max(20px, env(safe-area-inset-bottom));
      text-align: center;
      background: radial-gradient(circle at top, rgba(90, 52, 170, 0.85), rgba(8, 8, 18, 0.96));
      border-radius: 8px;
      overflow: hidden;
    }
    #gameOverScreen {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(90, 52, 170, 0.85), rgba(8, 8, 18, 0.96));
      border-radius: 8px;
      padding: 24px;
      text-align: center;
    }
    #startScreen h1 {
      font-family: 'Orbitron', system-ui, sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.22em;
      color: #fdfbff;
      font-size: clamp(16px, 6.5vw, 28px);
      margin-top: 14px;
      margin-bottom: 8px;
      text-shadow:
        0 0 8px rgba(216, 145, 255, 0.9),
        0 0 18px rgba(174, 83, 255, 0.9),
        0 0 42px rgba(139, 62, 255, 0.8);
      animation: neonFlicker 2.6s ease-in-out infinite alternate;
      white-space: nowrap;
    }
    .sub {
      color: #b8b9ff;
      font-size: clamp(12px, 2.4vw, 14px);
      margin-bottom: 26px;
      opacity: 0.9;
    }
    .nickname-field {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      margin-bottom: 8px;
    }
    .nickname-label {
      font-size: 13px;
      color: #d8d5ff;
      letter-spacing: 0.06em;
      margin-bottom: 2px;
    }
    #nicknameInput {
      width: min(70vw, 260px);
      padding: 10px 14px;
      border-radius: 999px;
      border: 1px solid rgba(214, 178, 255, 0.9);
      background: rgba(8, 4, 24, 0.9);
      color: #fdfbff;
      font-size: 16px;
      text-align: center;
      outline: none;
      box-shadow:
        0 0 0 1px rgba(86, 60, 180, 0.9),
        0 0 16px rgba(157, 117, 255, 0.5);
    }
    #nicknameInput::placeholder {
      color: rgba(184, 185, 230, 0.7);
      letter-spacing: 0.18em;
      text-transform: uppercase;
    }
    #nicknameInput:focus {
      border-color: rgba(244, 214, 255, 1);
      box-shadow:
        0 0 0 1px rgba(222, 182, 255, 0.95),
        0 0 24px rgba(215, 165, 255, 0.9);
    }
    .nickname-error {
      min-height: 1.2em;
      font-size: 11px;
      color: #ff9ca6;
    }
    .start-hint {
      margin-top: 10px;
      font-size: clamp(10px, 2.4vw, 12px);
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(187, 189, 255, 0.9);
    }
    #startCharacter {
      width: min(48vw, 260px);
      max-height: 180px;
      object-fit: contain;
      image-rendering: auto;
      margin-bottom: 18px;
      animation: bikeJitter 0.09s infinite steps(2, end);
      filter: drop-shadow(0 0 14px rgba(206, 149, 255, 0.9));
      transform-origin: center bottom;
    }
    .btn {
      padding: 14px 40px;
      font-size: 18px;
      font-weight: 700;
      color: #fdfbff;
      background: radial-gradient(circle at top, rgba(142, 76, 255, 0.5), rgba(36, 18, 54, 0.9));
      border-radius: 999px;
      border: 1px solid rgba(214, 178, 255, 0.8);
      cursor: pointer;
      box-shadow:
        0 0 0 1px rgba(129, 93, 255, 0.7),
        0 10px 24px rgba(10, 0, 40, 0.85),
        0 0 28px rgba(209, 134, 255, 0.7);
      transition: transform 0.14s ease-out, box-shadow 0.18s ease-out, border-color 0.18s ease-out;
      touch-action: manipulation;
    }
    .btn:hover {
      transform: translateY(-1px) scale(1.05);
      box-shadow:
        0 0 0 1px rgba(222, 182, 255, 0.95),
        0 16px 36px rgba(10, 0, 40, 0.95),
        0 0 40px rgba(235, 175, 255, 1);
      border-color: rgba(244, 214, 255, 1);
    }
    .btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow:
        0 0 0 1px rgba(184, 135, 255, 0.8),
        0 6px 18px rgba(10, 0, 40, 0.9),
        0 0 20px rgba(209, 134, 255, 0.7);
    }
    .btn + .btn {
      margin-top: 10px;
    }
    #startBtn {
      margin-top: -5px;
    }
    #gameOverTitle {
      font-family: 'Orbitron', system-ui, sans-serif;
      text-transform: uppercase;
      letter-spacing: 0.28em;
      color: #fdfbff;
      font-size: clamp(30px, 6vw, 46px);
      margin-bottom: 10px;
      text-shadow:
        0 0 10px rgba(216, 145, 255, 0.9),
        0 0 24px rgba(174, 83, 255, 0.9),
        0 0 52px rgba(139, 62, 255, 0.85);
      animation: neonFlicker 2.2s ease-in-out infinite alternate;
    }
    #finalScoreLabel {
      margin-top: 4px;
      margin-bottom: 6px;
      font-size: clamp(12px, 2.8vw, 14px);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(188, 181, 255, 0.9);
    }
    #finalScore {
      color: #ffb4c9;
      font-size: clamp(26px, 6vw, 40px);
      font-weight: 800;
      margin-bottom: 8px;
      text-shadow: 0 0 14px rgba(255, 120, 180, 0.9);
    }
    #finalScore span { font-size: 18px; color: #ffd6e5; font-weight: 400; }
    #bestScore {
      color: #ffe5ff;
      font-size: clamp(18px, 4.5vw, 24px);
      font-weight: 600;
      margin-bottom: 8px;
      text-shadow: 0 0 10px rgba(200, 150, 255, 0.8);
    }
    #newRecordLabel {
      margin-top: 4px;
      margin-bottom: 18px;
      font-size: clamp(16px, 4.5vw, 22px);
      font-weight: 800;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: #ffdcff;
      text-shadow:
        0 0 10px rgba(245, 105, 255, 0.9),
        0 0 24px rgba(227, 60, 255, 0.9),
        0 0 46px rgba(190, 36, 255, 0.85);
      animation: newRecordPulse 1.5s ease-in-out infinite alternate;
      display: none;
    }

    #rankingContainer {
      margin-top: 12px;
      width: 100%;
      max-width: 380px;
      flex: 1;
      min-height: 300px;
      max-height: 55vh;
      overflow: hidden;
      padding: 10px 12px 4px;
      border-radius: 12px;
      background: radial-gradient(circle at top, rgba(54, 36, 110, 0.95), rgba(4, 0, 18, 0.95));
      box-shadow:
        0 0 0 1px rgba(142, 99, 255, 0.7),
        0 12px 26px rgba(0, 0, 0, 0.7);
    }
    .rank-tabs {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    .rank-tab {
      padding: 8px 15px;
      border-radius: 999px;
      border: 1px solid rgba(170, 140, 255, 0.8);
      background: rgba(12, 8, 40, 0.8);
      color: #d9d2ff;
      font-size: 13px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      cursor: pointer;
    }
    .rank-tab.active {
      background: linear-gradient(135deg, #e94560, #9b5bff);
      color: #fff;
      box-shadow: 0 0 18px rgba(222, 152, 255, 0.9);
    }
    .rank-list {
      list-style: none;
      padding: 0 5px 100px 0 !important;
      margin: 0;
      width: 100%;
      text-align: left;
      font-size: clamp(11px, 2.8vw, 13px);
      height: 100%;
      min-height: 0;
      max-height: 100%;
      overflow-y: auto;
      touch-action: pan-y !important;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scrollbar-color: #9b5bff rgba(10, 4, 40, 0.9);
    }
    .rank-list::-webkit-scrollbar {
      width: 6px;
    }
    .rank-list::-webkit-scrollbar-track {
      background: rgba(10, 4, 40, 0.85);
      border-radius: 999px;
    }
    .rank-list::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #e94560, #9b5bff);
      border-radius: 999px;
    }
    .rank-list::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #ff6b8b, #b787ff);
    }
    .rank-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 4px 10px;
      margin-bottom: 4px;
      border-radius: 6px;
      background: rgba(10, 4, 36, 0.9);
      box-shadow: 0 0 0 1px rgba(107, 81, 210, 0.7);
    }
    .rank-item.rank-top1 {
      font-size: 1.4em;
      padding-top: 6px;
      padding-bottom: 6px;
    }
    .rank-item.rank-top2 {
      font-size: 1.25em;
      padding-top: 5px;
      padding-bottom: 5px;
    }
    .rank-item.rank-top3 {
      font-size: 1.12em;
    }
    .rank-item.loading,
    .rank-item.error {
      justify-content: center;
      color: #c5b8ff;
      opacity: 0.85;
      padding-top: 80px;
      padding-bottom: 80px;
      min-height: 120px;
      box-sizing: border-box;
    }
    .rank-pos {
      min-width: 3em;
      text-align: center;
      color: #f4b5ff;
      font-weight: 700;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .rank-medal {
      display: inline-block;
      margin-left: 4px;
      font-size: 1.1em;
    }
    .rank-name {
      flex: 1;
      color: #fdfbff;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .rank-score {
      min-width: 4.5em;
      text-align: right;
      color: #ffcfdf;
    }
    .player-rank-info {
      margin-top: 10px;
      padding-bottom: 10px;
      font-size: clamp(11px, 2.8vw, 13px);
      color: #c6b6ff;
      text-align: center;
    }

    #fadeOverlay {
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at 20% 0%, rgba(255,255,255,0.9) 0, rgba(180,120,255,0.95) 24%, rgba(10,0,32,0.98) 80%);
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
    }

    #fadeOverlay.fade-start {
      animation: startFlash 0.55s ease-in-out forwards;
    }

    @keyframes startFlash {
      0%   { opacity: 0; }
      20%  { opacity: 1; }
      100% { opacity: 0; }
    }

    @keyframes neonFlicker {
      0% {
        text-shadow:
          0 0 8px rgba(216, 145, 255, 0.8),
          0 0 22px rgba(174, 83, 255, 0.8),
          0 0 40px rgba(139, 62, 255, 0.7);
        opacity: 0.96;
      }
      8% {
        text-shadow:
          0 0 4px rgba(216, 145, 255, 0.3),
          0 0 10px rgba(174, 83, 255, 0.3),
          0 0 20px rgba(139, 62, 255, 0.3);
        opacity: 0.72;
      }
      10% {
        text-shadow:
          0 0 12px rgba(242, 210, 255, 1),
          0 0 28px rgba(210, 125, 255, 1),
          0 0 52px rgba(163, 81, 255, 1);
        opacity: 1;
      }
      28% {
        text-shadow:
          0 0 8px rgba(216, 145, 255, 0.85),
          0 0 20px rgba(174, 83, 255, 0.9),
          0 0 46px rgba(139, 62, 255, 0.8);
        opacity: 0.98;
      }
      30% {
        text-shadow:
          0 0 2px rgba(216, 145, 255, 0.3),
          0 0 8px rgba(174, 83, 255, 0.3),
          0 0 14px rgba(139, 62, 255, 0.3);
        opacity: 0.84;
      }
      32% {
        text-shadow:
          0 0 14px rgba(242, 210, 255, 1),
          0 0 34px rgba(210, 125, 255, 1),
          0 0 60px rgba(163, 81, 255, 1);
        opacity: 1;
      }
      100% {
        text-shadow:
          0 0 10px rgba(216, 145, 255, 0.9),
          0 0 26px rgba(174, 83, 255, 0.9),
          0 0 54px rgba(139, 62, 255, 0.85);
        opacity: 0.97;
      }
    }

    @keyframes bikeJitter {
      0%   { transform: translateY(0px); }
      20%  { transform: translateY(-1px); }
      40%  { transform: translateY(1px); }
      60%  { transform: translateY(-2px); }
      80%  { transform: translateY(1px); }
      100% { transform: translateY(0px); }
    }

    @keyframes gridScroll {
      0% {
        background-position:
          0 0,
          0 0,
          0 0;
      }
      100% {
        background-position:
          0 0,
          0 260px,
          260px 0;
      }
    }
    @keyframes newRecordPulse {
      0% {
        opacity: 0.85;
        text-shadow:
          0 0 6px rgba(245, 105, 255, 0.7),
          0 0 18px rgba(227, 60, 255, 0.7),
          0 0 32px rgba(190, 36, 255, 0.7);
        transform: translateY(0px) scale(1);
      }
      35% {
        opacity: 1;
        text-shadow:
          0 0 12px rgba(255, 180, 255, 1),
          0 0 32px rgba(246, 109, 255, 1),
          0 0 60px rgba(207, 62, 255, 1);
        transform: translateY(-1px) scale(1.03);
      }
      50% {
        opacity: 0.9;
        text-shadow:
          0 0 4px rgba(245, 105, 255, 0.6),
          0 0 14px rgba(227, 60, 255, 0.6),
          0 0 26px rgba(190, 36, 255, 0.6);
        transform: translateY(0px) scale(0.99);
      }
      100% {
        opacity: 1;
        text-shadow:
          0 0 10px rgba(245, 105, 255, 0.9),
          0 0 26px rgba(227, 60, 255, 0.9),
          0 0 46px rgba(190, 36, 255, 0.85);
        transform: translateY(-0.5px) scale(1.02);
      }
    }
  </style>
  <!-- Supabase JavaScript SDKï¼ˆCDN / UMD ãƒ“ãƒ«ãƒ‰ï¼‰ -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
</head>
<body class="start-screen">
  <canvas id="bgStarsCanvas" aria-hidden="true"></canvas>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="450"></canvas>
    <div id="uiOverlay">
      <div id="fadeOverlay"></div>
      <div id="scoreDisplay">0 m</div>
      <div id="startScreen">
        <h1>ğŸŸ£Purple BikerğŸŸ£</h1>
        <img id="startCharacter" src="é€éæ¸ˆ.png" alt="Purple Biker">
        <div class="nickname-field">
          <p class="nickname-label">ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„</p>
          <input id="nicknameInput" type="text" maxlength="16" autocomplete="off" inputmode="text" placeholder="ä¾‹ï¼šã‚€ã‚‰ã•ãå¤ªéƒ">
          <div id="nicknameError" class="nickname-error"></div>
        </div>
        <button class="btn" id="startBtn">START GAME</button>
        <div id="rankingContainer">
          <div class="rank-tabs">
            <button class="rank-tab active" data-rank-range="today">TODAY</button>
            <button class="rank-tab" data-rank-range="week">WEEK</button>
            <button class="rank-tab" data-rank-range="all">ALL TIME</button>
          </div>
          <ul id="rankList" class="rank-list"></ul>
          <div id="playerRankInfo" class="player-rank-info"></div>
        </div>
      </div>
      <div id="gameOverScreen">
        <h1 id="gameOverTitle">GAME OVER</h1>
        <p id="finalScoreLabel">SCORE</p>
        <p id="finalScore">0 <span>m</span></p>
        <p id="bestScore">BEST: 0 <span>m</span></p>
        <p id="newRecordLabel">NEW RECORD!</p>
        <button class="btn" id="retryBtn">ã‚‚ã†ä¸€åº¦èµ°ã‚‹</button>
        <button class="btn btn-secondary" id="backToTitleBtn">ãƒˆãƒƒãƒ—ã¸æˆ»ã‚‹</button>
      </div>
    </div>
  </div>

  <script>
(function() {
  'use strict';

  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const CW = 800, CH = 450;

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  let state = 'start'; // start | playing | gameover
  let scrollSpeed = 0;
  const BASE_SPEED = 6;
  const MAX_SPEED = 14;
  const SPEED_INCREASE_PER_M = 0.008;
  let distance = 0;
  let lastTime = 0;
  let hasShownGameOver = false;

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç”»é¢å·¦å¯„ã‚Šå›ºå®šã®è¦‹ãŸç›® = ãƒ¯ãƒ¼ãƒ«ãƒ‰ã§ã¯å³ã«é€²ã‚€ã®ã§ã€åœ°å½¢ã‚’å·¦ã«æµã™ï¼‰
  const PLAYER_WORLD_X = 120;  // ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã§ã®è¦‹ãŸç›®ã®Xï¼ˆå›ºå®šï¼‰
  const PLAYER_WIDTH = 60;   // ãƒã‚¤ã‚¯ã«åˆã‚ã›ã¦æ¨ªé•·ã®å½“ãŸã‚Šåˆ¤å®š
  const PLAYER_HEIGHT = 40;
  const PLAYER_DRAW_OFFSET_X = 0;  // æç”»ä½ç½®ã®å¾®èª¿æ•´ï¼ˆåœ°é¢ã¨ã®è¦‹ãŸç›®åˆã‚ã›ï¼‰
  const PLAYER_DRAW_OFFSET_Y = 0;
  let playerY = 0;
  let velY = 0;
  const GRAVITY = 0.65;
  const JUMP_POWER = -11.5;
  const DOUBLE_JUMP_POWER = -9.5;
  let onGround = false;
  let canDoubleJump = false;
  let usedDoubleJump = false;

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç”»åƒï¼ˆé€éæ¸ˆ.pngï¼‰
  const playerImage = new Image();
  let playerImgLoaded = false;
  playerImage.onload = function() { playerImgLoaded = true; };
  playerImage.src = 'é€éæ¸ˆ.png';

  // å…¥åŠ›ç®¡ç†ï¼ˆã‚¹ãƒšãƒ¼ã‚¹æŠ¼ã—ã£ã±ãªã—å¯¾ç­–ï¼‰
  let spaceHeld = false;

  // åŠ¹æœéŸ³ï¼ˆWeb Audio APIï¼‰
  let audioCtx = null;
  let audioReady = false;
  let distortionCurve = null;
  let bestScore = 0;
  let jumpBuffer = null;
  let jumpBufferLoading = false;

  // Supabase ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ
  let supabaseClient = null;

  // èƒŒæ™¯ç”¨ã‚¨ãƒ¬ãƒ¡ãƒ³ãƒˆï¼ˆæ˜Ÿç©ºãƒ»è¡—ã®ã‚·ãƒ«ã‚¨ãƒƒãƒˆï¼‰
  let stars = [];
  let cityBlocks = [];
  // å…¨ç”»é¢ç”¨ã®æ˜Ÿç©ºï¼ˆãƒ—ãƒ¬ã‚¤ä¸­ã«ã‚¹ãƒãƒ›æœ€ä¸Šéƒ¨ã¾ã§è¡¨ç¤ºï¼‰
  let bgStars = [];
  let bgClouds = [];
  let bgCtx = null;
  let bgCanvasWidth = 0;
  let bgCanvasHeight = 0;

  function initSupabase() {
    if (supabaseClient || !window.supabase) return;

    // Supabase ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆè¨­å®š
    // Netlify ç­‰ã®ç’°å¢ƒå¤‰æ•°ã‚’ä½¿ã†å ´åˆã®ä¾‹:
    // const supabaseUrl = 'https://hefayilffszrczxhnpii.supabase.co' || import.meta.env.VITE_SUPABASE_URL;
    // const supabaseKey = 'sb_publishable_w1O4J9Cg9I0LWjoFpb5_pg_uDxUHnOd' || import.meta.env.VITE_SUPABASE_ANON_KEY;

    // TODO: ã”è‡ªèº«ã® Supabase ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã® URL ã¨ anon å…¬é–‹éµã«æ›¸ãæ›ãˆã¦ãã ã•ã„
    const supabaseUrl = 'https://hefayilffszrczxhnpii.supabase.co';
    const supabaseKey = 'sb_publishable_w1O4J9Cg9I0LWjoFpb5_pg_uDxUHnOd';

    try {
      supabaseClient = window.supabase.createClient(supabaseUrl, supabaseKey);
    } catch (e) {
      console.error('Supabase åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
      supabaseClient = null;
    }
  }

  function initAudioContext() {
    if (!window.AudioContext && !window.webkitAudioContext) return;
    if (!audioCtx) {
      const Ctx = window.AudioContext || window.webkitAudioContext;
      audioCtx = new Ctx();
    }
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
    audioReady = true;
  }

  async function loadJumpSoundBuffer() {
    if (!audioCtx || jumpBufferLoading || jumpBuffer) return;
    jumpBufferLoading = true;
    try {
      // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚©ãƒ«ãƒ€å†…ã®ã€Œjump.mp3ã€ã‚’ã‚¸ãƒ£ãƒ³ãƒ—SEã¨ã—ã¦ä½¿ç”¨
      const response = await fetch('jump.mp3');
      if (!response.ok) throw new Error('HTTP ' + response.status + ' while loading jump sound jump.mp3');
      const arrayBuf = await response.arrayBuffer();
      const decoded = await audioCtx.decodeAudioData(arrayBuf);
      jumpBuffer = decoded;
    } catch (e) {
      console.error('ã‚¸ãƒ£ãƒ³ãƒ—SE(jump.mp3)ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
    } finally {
      jumpBufferLoading = false;
    }
  }

  function playJumpSound() {
    if (!audioCtx || !audioReady) {
      console.error('ã‚¸ãƒ£ãƒ³ãƒ—SEå†ç”Ÿæ™‚ã« AudioContext ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
      return;
    }
    const ctx = audioCtx;

    // äº‹å‰ãƒ‡ã‚³ãƒ¼ãƒ‰æ¸ˆã¿ã® jump.mp3 ãŒã‚ã‚Œã°ãã‚Œã‚’å†ç”Ÿ
    if (jumpBuffer) {
      const src = ctx.createBufferSource();
      const gain = ctx.createGain();
      src.buffer = jumpBuffer;
      src.connect(gain);
      gain.connect(ctx.destination);
      gain.gain.setValueAtTime(0.9, ctx.currentTime);
      src.start(ctx.currentTime);
      return;
    }

    // ãƒãƒƒãƒ•ã‚¡ãŒã¾ã å­˜åœ¨ã—ãªã„å ´åˆ
    console.error('ã‚¸ãƒ£ãƒ³ãƒ—SE(jump.mp3)ã®AudioBufferãŒæœªæº–å‚™ã®ãŸã‚ã€éŸ³ã‚’å†ç”Ÿã§ãã¾ã›ã‚“ã§ã—ãŸ');
  }

  function playLandSound() {
    if (!audioCtx || !audioReady) return;
    const ctx = audioCtx;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'triangle';
    osc.frequency.setValueAtTime(150, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(12, ctx.currentTime + 0.16);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(600, ctx.currentTime);
    filter.frequency.exponentialRampToValueAtTime(180, ctx.currentTime + 0.16);

    gain.gain.setValueAtTime(0.0, ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0.6, ctx.currentTime + 0.02);
    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.22);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    osc.start(ctx.currentTime);
    osc.stop(ctx.currentTime + 0.25);
  }

  function playHitSound() {
    if (!audioCtx || !audioReady) return;
    const ctx = audioCtx;
    const now = ctx.currentTime;

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // ä½éŸ³ã§é‡ã¿ã®ã‚ã‚‹ã€Œãƒ‰ã‚«ãƒƒï¼ã€ç³»
    osc.type = 'square';
    osc.frequency.setValueAtTime(140, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.22);

    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(700, now);
    filter.frequency.exponentialRampToValueAtTime(180, now + 0.22);

    gain.gain.setValueAtTime(0.0, now);
    gain.gain.linearRampToValueAtTime(0.85, now + 0.015);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.32);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + 0.35);
  }

  async function saveScoreToSupabase(name, score) {
    initSupabase();
    if (!supabaseClient) return;
    const payload = { nickname: name, score };
    // created_at ã¯ Supabase å´ã§ now() ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚’è¨­å®šã—ã¦ãŠãæƒ³å®šï¼ˆbiker_scores ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
    const { error } = await supabaseClient.from('biker_scores').insert(payload);
    if (error) throw error;
  }

  async function submitScoreAndLoadRanking() {
    if (!rankListEl) return;
    const score = Math.floor(distance);
    const name = currentNickname || (nicknameInput ? nicknameInput.value.trim() : '') || 'NONAME';
    lastSubmittedScore = score;
    lastSubmittedNickname = name;

    try {
      await saveScoreToSupabase(name, score);
    } catch (e) {
      console.error('Supabase ã¸ã®ã‚¹ã‚³ã‚¢ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ', e);
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ä»Šæ—¥ã®ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’è¡¨ç¤º
    loadRanking('today');
  }

  async function loadRanking(range) {
    currentRankRange = range;
    if (!rankListEl) return;
    rankListEl.innerHTML = '<li class="rank-item loading">Loading...</li>';
    if (playerRankInfoEl) playerRankInfoEl.textContent = '';

    initSupabase();
    if (!supabaseClient) {
      rankListEl.innerHTML = '<li class="rank-item error">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚</li>';
      return;
    }

    const now = new Date();
    let fromDate = null;

    if (range === 'today') {
      const d = new Date(now);
      d.setHours(0, 0, 0, 0);
      fromDate = d;
    } else if (range === 'week') {
      const d = new Date(now);
      d.setDate(d.getDate() - 6); // ç›´è¿‘7æ—¥é–“ï¼ˆä»Šæ—¥ã‚’å«ã‚€ï¼‰
      d.setHours(0, 0, 0, 0);
      fromDate = d;
    }

    try {
      // ä¸Šä½ 10 ä»¶ã®å–å¾—ï¼ˆbiker_scores ãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
      let baseQuery = supabaseClient
        .from('biker_scores')
        .select('id,nickname,score,created_at', { count: 'exact' });

      if (fromDate) {
        baseQuery = baseQuery.gte('created_at', fromDate.toISOString());
      }

      const { data: rows, error } = await baseQuery
        .order('score', { ascending: false })
        .limit(100);

      if (error) throw error;

      // è¡¨ç¤ºç”¨ï¼šåŒã˜ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã¯æœ€é«˜ã‚¹ã‚³ã‚¢ã®1ä»¶ã ã‘ã«é›†ç´„ï¼ˆfetch ã¨é †ä½è¨ˆç®—ã§å®Œå…¨ã«åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã«ã™ã‚‹ï¼‰
      const bestByName = new Map();
      (rows || []).forEach((entry) => {
        const nicknameKey = entry.nickname || entry.name || 'UNKNOWN';
        const scoreVal = typeof entry.score === 'number' ? entry.score : (entry.value || 0);
        const existing = bestByName.get(nicknameKey);
        if (!existing || scoreVal > (typeof existing.score === 'number' ? existing.score : (existing.value || 0))) {
          bestByName.set(nicknameKey, entry);
        }
      });
      const deduped = Array.from(bestByName.values());
      deduped.sort((a, b) => {
        const sa = typeof a.score === 'number' ? a.score : (a.value || 0);
        const sb = typeof b.score === 'number' ? b.score : (b.value || 0);
        return sb - sa;
      });

      // è‡ªåˆ†ã®é †ä½ã¯ã€Œè¡¨ç¤ºç”¨ã®é‡è¤‡æ’é™¤ãƒªã‚¹ãƒˆã€å†…ã®ä½ç½®ã¨ä¸€è‡´ã•ã›ã‚‹ï¼ˆè¡¨ã®è¡Œã¨ä¸‹ã®é †ä½è¡¨ç¤ºãŒå¿…ãšä¸€è‡´ï¼‰
      let self = null;
      if (lastSubmittedNickname && lastSubmittedScore > 0) {
        const idx = deduped.findIndex((e) => (e.nickname || e.name) === lastSubmittedNickname);
        if (idx !== -1) {
          const entry = deduped[idx];
          const s = typeof entry.score === 'number' ? entry.score : (entry.value || 0);
          self = { rank: idx + 1, nickname: lastSubmittedNickname, score: s };
        }
      }

      renderRanking({ top: deduped, self }, range);
    } catch (e) {
      console.error('load ranking failed', e);
      if (rankListEl) rankListEl.innerHTML = '<li class="rank-item error">ãƒ©ãƒ³ã‚­ãƒ³ã‚°å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸã€‚å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚</li>';
    }
  }

  function renderRanking(data, range) {
    if (!rankListEl) return;
    // loadRanking ã‹ã‚‰æ¸¡ã•ã‚Œã‚‹ top ã¯é‡è¤‡æ’é™¤ãƒ»ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã®ãŸã‚ãã®ã¾ã¾ä½¿ç”¨
    const deduped = data && (data.top || data.rows || data.list || []);
    const self = data && (data.self || null);

    const toRender = deduped.slice(0, 100);
    if (typeof console !== 'undefined' && console.log) {
      console.log('[renderRanking] deduped.length=', deduped.length, 'rendering items=', toRender.length);
    }

    rankListEl.innerHTML = '';

    let lastScore = null;
    let lastRank = 0;
    let shownCount = 0;

    toRender.forEach((entry, index) => {
      const li = document.createElement('li');
      li.className = 'rank-item';
      const score = typeof entry.score === 'number' ? entry.score : (entry.value || 0);

      let displayRank;
      if (lastScore === null) {
        // æœ€åˆã®è¡Œ
        displayRank = 1;
      } else if (score === lastScore) {
        // åŒã‚¹ã‚³ã‚¢ã¯åŒã˜é †ä½ï¼ˆã‚¿ã‚¤ï¼‰
        displayRank = lastRank;
      } else {
        // ç•°ãªã‚‹ã‚¹ã‚³ã‚¢ã¯ã€Œã“ã‚Œã¾ã§ã«è¡¨ç¤ºã—ãŸä»¶æ•° + 1ã€ä½
        displayRank = shownCount + 1;
      }
      lastScore = score;
      lastRank = displayRank;
      shownCount += 1;

      const nickname = entry.nickname || entry.name || 'UNKNOWN';

      // ä¸Šä½3ä½ã¯è¡Œå…¨ä½“ã‚’å¤§ããã™ã‚‹ãŸã‚ã®ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸
      if (displayRank === 1) li.classList.add('rank-top1');
      else if (displayRank === 2) li.classList.add('rank-top2');
      else if (displayRank === 3) li.classList.add('rank-top3');

      let rankContent = '';
      if (displayRank === 1) rankContent = '<span class="rank-medal">ğŸ¥‡</span>';
      else if (displayRank === 2) rankContent = '<span class="rank-medal">ğŸ¥ˆ</span>';
      else if (displayRank === 3) rankContent = '<span class="rank-medal">ğŸ¥‰</span>';
      else rankContent = '#' + displayRank;

      li.innerHTML =
        '<span class="rank-pos">' + rankContent + '</span>' +
        '<span class="rank-name">' + nickname + '</span>' +
        '<span class="rank-score">' + score + ' m</span>';
      rankListEl.appendChild(li);
    });

    if (playerRankInfoEl) {
      if (self && self.rank) {
        const sName = self.nickname || self.name || lastSubmittedNickname;
        const sScore = typeof self.score === 'number' ? self.score : (self.value || lastSubmittedScore);
        playerRankInfoEl.textContent =
          sName + ' ã®é †ä½: ' + self.rank + ' ä½ / ' + sScore + ' m';
      } else if (lastSubmittedNickname) {
        playerRankInfoEl.textContent =
          lastSubmittedNickname + ' ã®è¨˜éŒ²: ' + lastSubmittedScore + ' m';
      }
    }

    if (rankTabs && rankTabs.length) {
      rankTabs.forEach(btn => {
        const r = btn.getAttribute('data-rank-range') || '';
        btn.classList.toggle('active', r === range);
      });
    }
  }

  // åœ°å½¢ãƒ–ãƒ­ãƒƒã‚¯ { x, y, w, h } ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼ˆx ã¯å·¦ç«¯ï¼‰
  let terrain = [];
  let worldOffset = 0;  // åœ°å½¢ã‚’å·¦ã«ãšã‚‰ã™é‡ï¼ˆå¢—ãˆã‚‹ã¨ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ï¼‰

  const GROUND_Y_BASE = CH - 80;
  const BLOCK_HEIGHT = 60;
  const MIN_BLOCK_WIDTH = 80;
  const MAX_BLOCK_WIDTH = 220;
  const MIN_GAP = 90;   // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å¹…(60)ã‚ˆã‚Šååˆ†åºƒã„éš™é–“ã‚’å¿…ãšç”Ÿæˆ
  const MAX_GAP = 160;
  const MAX_STEP = 80;
  const MIN_STEP_HEIGHT = 24;   // è¦–èªã§ãã‚‹æ®µå·®ã®æœ€å°é«˜ã•
  const MAX_STEP_UP = 60;       // ä¸Šæ–¹å‘ã®æœ€å¤§æ®µå·®ï¼ˆã‚¸ãƒ£ãƒ³ãƒ—ã§å±Šãç¯„å›²ï¼‰
  const MAX_STEP_DOWN = 80;     // ä¸‹æ–¹å‘ã®æœ€å¤§æ®µå·®
  let nextGenX = 0;

  const scoreEl = document.getElementById('scoreDisplay');
  const startScreen = document.getElementById('startScreen');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEl = document.getElementById('bestScore');
  const newRecordLabelEl = document.getElementById('newRecordLabel');
  const fadeOverlay = document.getElementById('fadeOverlay');
  const backToTitleBtn = document.getElementById('backToTitleBtn');
  const nicknameInput = document.getElementById('nicknameInput');
  const nicknameError = document.getElementById('nicknameError');
  const rankTabs = document.querySelectorAll('.rank-tab[data-rank-range]');
  const rankListEl = document.getElementById('rankList');
  const playerRankInfoEl = document.getElementById('playerRankInfo');

  let currentNickname = '';
  let lastSubmittedScore = 0;
  let lastSubmittedNickname = '';
  let currentRankRange = 'today';

  function getGroundY() {
    return GROUND_Y_BASE;
  }

  function loadNickname() {
    if (!nicknameInput) return;
    const saved = localStorage.getItem('pb_nickname') || '';
    nicknameInput.value = saved;
    currentNickname = saved.trim();
  }

  function loadBestScore() {
    try {
      const raw = localStorage.getItem('pb_best_score');
      const v = raw ? parseInt(raw, 10) : 0;
      if (!Number.isNaN(v) && v > 0) {
        bestScore = v;
        if (bestScoreEl) bestScoreEl.innerHTML = 'BEST: ' + bestScore + ' <span>m</span>';
      }
    } catch (e) {
      bestScore = 0;
    }
  }

  function updateBestScoreIfNeeded(current) {
    const score = Math.floor(current);
    if (score <= 0) return false;
    let isNewRecord = false;
    if (score > bestScore) {
      bestScore = score;
      try {
        localStorage.setItem('pb_best_score', String(bestScore));
      } catch (e) {
        // ignore
      }
      isNewRecord = true;
    }
    if (bestScoreEl) bestScoreEl.innerHTML = 'BEST: ' + bestScore + ' <span>m</span>';
    return isNewRecord;
  }

  function initGame() {
    state = 'playing';
    scrollSpeed = BASE_SPEED;
    distance = 0;
    worldOffset = 0;
    terrain = [];
    nextGenX = 0;
    velY = 0;
    onGround = true;
    canDoubleJump = false;
    usedDoubleJump = false;
    // åˆæœŸåœ°é¢ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‹ã‚‰ååˆ†å³å´ã¾ã§æ•·ã
    const startGroundW = 600;
    const groundY = getGroundY();
    terrain.push({
      x: 0,
      y: groundY,
      w: startGroundW,
      h: CH - groundY
    });
    nextGenX = startGroundW;
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸYåº§æ¨™ã‚’æœ€åˆã®åœ°é¢ãƒ–ãƒ­ãƒƒã‚¯ã«åˆã‚ã›ã¦å¼·åˆ¶è¨­å®š
    playerY = terrain[0].y - PLAYER_HEIGHT;

    document.body.classList.remove('start-screen');
    if (scoreEl) scoreEl.style.display = 'block';
    if (startScreen) startScreen.style.display = 'none';
    if (gameOverScreen) gameOverScreen.style.display = 'none';
    hasShownGameOver = false;
  }

  function resetToTitle() {
    state = 'start';
    document.body.classList.add('start-screen');
    if (scoreEl) scoreEl.style.display = 'none';
    if (startScreen) startScreen.style.display = 'flex';
    if (gameOverScreen) gameOverScreen.style.display = 'none';
    hasShownGameOver = false;
    if (rankListEl) rankListEl.innerHTML = '';
    if (playerRankInfoEl) playerRankInfoEl.textContent = '';
    loadRanking(currentRankRange || 'today');
  }

  function startGameWithTransition() {
    if (state !== 'start') return;
    // éŸ³å£°ãƒãƒªã‚·ãƒ¼å¯¾ç­–: ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«ã‚‚ç¢ºå®Ÿã«AudioContextã‚’åˆæœŸåŒ–ã—ã€ã‚¸ãƒ£ãƒ³ãƒ—SEã‚’èª­ã¿è¾¼ã‚€
    initAudioContext();
    if (audioCtx && !jumpBuffer && !jumpBufferLoading) {
      loadJumpSoundBuffer();
    }
    if (nicknameInput) {
      const name = nicknameInput.value.trim();
      if (!name) {
        if (nicknameError) nicknameError.textContent = 'ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        nicknameInput.focus();
        return;
      }
      currentNickname = name;
      try {
        localStorage.setItem('pb_nickname', name);
      } catch (e) {
        // ignore
      }
    }
    if (!fadeOverlay) {
      initGame();
      return;
    }
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªã‚¹ã‚¿ãƒ¼ãƒˆã™ã‚‹ãŸã‚ã«ã‚¯ãƒ©ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
    fadeOverlay.classList.remove('fade-start');
    // å†æç”»ã‚’å¼·åˆ¶ã—ã¦ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ãƒªãƒ—ãƒ¬ã‚¤
    void fadeOverlay.offsetWidth; // eslint-disable-line no-unused-expressions
    const handleEnd = () => {
      fadeOverlay.removeEventListener('animationend', handleEnd);
      initGame();
    };
    fadeOverlay.addEventListener('animationend', handleEnd);
    fadeOverlay.classList.add('fade-start');
  }

  function generateTerrain() {
    const rightEdge = worldOffset + CW + 150;
    while (nextGenX < rightEdge) {
      const roll = Math.random();
      const last = terrain.length > 0 ? terrain[terrain.length - 1] : null;
      const lastRight = last ? last.x + last.w : 0;
      const startX = nextGenX;
      // ç©´ï¼ˆã‚®ãƒ£ãƒƒãƒ—ï¼‰: ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã›ãšæ¬¡ã¸ï¼ˆ2000mè¶…ã§å‡ºç¾ç¢ºç‡ã‚’æ®µéšçš„ã«ã‚¢ãƒƒãƒ—ï¼‰
      // åŸºæœ¬22%ã€‚3000mè¶…ã§32%ã«ä¸Šã’ã€ä¸­ç›¤ä»¥é™ã®ãƒªã‚ºãƒ ã‚’ç¶­æŒ
      let gapThreshold = 0.22;
      if (distance > 3000) {
        gapThreshold = 0.32;
      } else if (distance > 2000) {
        gapThreshold = 0.28;
      }
      if (roll < gapThreshold && last) {
        // ç¾åœ¨ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é€Ÿåº¦ã«æ¯”ä¾‹ã—ãŸã€å®‰å…¨ãªæœ€å¤§å¹…ï¼ˆäºŒæ®µã‚¸ãƒ£ãƒ³ãƒ—ã§ä½™è£•ã‚’æŒã£ã¦å±Šãç¯„å›²ã«åˆ¶é™ï¼‰
        const maxSafeGap = scrollSpeed * 8.0;
        let gapMax = Math.max(MIN_GAP, Math.min(MAX_GAP, maxSafeGap));
        // ç©´ã®å¾Œã®ãƒ–ãƒ­ãƒƒã‚¯ãŒå‰ã‚ˆã‚Šé«˜ã„å ´åˆï¼ˆä¸Šã‚Šå‚ï¼‰ã¯ã€é£›è·é›¢ãŒè½ã¡ã‚‹ãŸã‚ gapMax ã‚’ 20% çŸ­ãã™ã‚‹
        const nextIsStep = Math.random();
        if (nextIsStep < 0.5) {
          const stepVal = (Math.random() - 0.5) * 2 * MAX_STEP;
          if (stepVal < -MIN_STEP_HEIGHT) gapMax = Math.max(MIN_GAP, gapMax * 0.8);
        }
        const gapW = MIN_GAP + Math.random() * (gapMax - MIN_GAP);
        nextGenX = startX + gapW;
        continue;
      }
      // æ®µå·®ï¼ˆé«˜ã„å£ or ä½ã„è°·ï¼‰
      if (roll < 0.5 && last) {
        let step = (Math.random() - 0.5) * 2 * MAX_STEP;
        const absStep = Math.abs(step);
        // ã»ã¨ã‚“ã©å¹³å¦ãªæ•°ãƒ”ã‚¯ã‚»ãƒ«æ®µå·®ã¯å»ƒæ­¢
        if (absStep < MIN_STEP_HEIGHT) {
          step = 0;
        } else {
          // ä¸Šæ–¹å‘ã®ç†ä¸å°½ãªæ®µå·®ãƒ»ä¸‹æ–¹å‘ã®æ€¥ãªè½å·®ã‚’åˆ¶é™
          if (step < -MAX_STEP_UP) step = -MAX_STEP_UP;
          if (step > MAX_STEP_DOWN) step = MAX_STEP_DOWN;
        }
        const blockW = MIN_BLOCK_WIDTH + Math.random() * (MAX_BLOCK_WIDTH - MIN_BLOCK_WIDTH);
        const topY = last.y + step;
        const actualY = Math.max(80, Math.min(CH - BLOCK_HEIGHT, topY));
        terrain.push({
          x: startX,
          y: actualY,
          w: blockW,
          h: CH - actualY
        });
        nextGenX = startX + blockW;
        continue;
      }
      // å¹³å¦
      const blockW = MIN_BLOCK_WIDTH + Math.random() * (MAX_BLOCK_WIDTH - MIN_BLOCK_WIDTH);
      const y = last ? last.y : getGroundY();
      terrain.push({
        x: startX,
        y: y,
        w: blockW,
        h: CH - y
      });
      nextGenX = startX + blockW;
    }
  }

  function removeOffscreenTerrain() {
    const leftEdge = worldOffset - 50;
    terrain = terrain.filter(b => b.x + b.w > leftEdge);
  }

  function jump() {
    let didJump = false;
    if (onGround) {
      velY = JUMP_POWER;
      onGround = false;
      canDoubleJump = true;
      usedDoubleJump = false;
      didJump = true;
    } else if (canDoubleJump && !usedDoubleJump) {
      velY = DOUBLE_JUMP_POWER;
      usedDoubleJump = true;
      didJump = true;
    }
    if (didJump) {
      initAudioContext();
      playJumpSound();
    }
  }

  function updatePlayer(dt) {
    const wasGroundedBefore = onGround;
    let landedThisFrame = false;

    // é‡åŠ›é©ç”¨
    velY += GRAVITY * (dt / 16);
    playerY += velY;
    onGround = false;

    const playerLeft = PLAYER_WORLD_X - PLAYER_WIDTH / 2;
    const playerRight = PLAYER_WORLD_X + PLAYER_WIDTH / 2; // å‰è¼ªï¼ˆè»Šä½“å³ç«¯ï¼‰
    const playerFeetY = playerY + PLAYER_HEIGHT;
    const rearX = PLAYER_WORLD_X - 20;                     // å¾Œè¼ªä»˜è¿‘
    const LAND_MARGIN = 10;                                // ç€åœ°ã¨ã¿ãªã™é«˜ã•ã®çŒ¶äºˆ

    for (const block of terrain) {
      const blockScreenLeft = block.x - worldOffset;
      const blockScreenRight = block.x + block.w - worldOffset;
      const blockTop = block.y;

      // 1. æ­£é¢ã‹ã‚‰é«˜ã„å£ã«ã¶ã¤ã‹ã£ãŸã‹ï¼ˆæœ€å„ªå…ˆã§ãƒã‚§ãƒƒã‚¯ï¼‰
      const frontOverLeftEdge = playerRight > blockScreenLeft + 15; // 15px ä»¥ä¸Šã‚ã‚Šè¾¼ã‚“ã ã‚‰è¡çªæ‰±ã„
      const centerStillLeftOfWall = PLAYER_WORLD_X < blockScreenLeft;
      const feetDeepBelowTop = playerFeetY > blockTop + 8; // æ®µå·®è¨±å®¹ï¼š8pxã‚ˆã‚Šæ·±ãæ²ˆã‚“ã ã‚‰å£

      if (frontOverLeftEdge && centerStillLeftOfWall && feetDeepBelowTop) {
        // ç€åœ°å¯èƒ½ãªé«˜ã•ã§ã¯ãªãã€é«˜ã„å£ã«å‰è¼ªãŒã¶ã¤ã‹ã£ãŸ â†’ å³ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        if (state === 'playing') {
          initAudioContext();
          playHitSound();
        }
        state = 'gameover';
        return;
      }

      // 2. ç€åœ°åˆ¤å®šï¼ˆå‰è¼ªã¾ãŸã¯å¾Œè¼ªãŒãƒ–ãƒ­ãƒƒã‚¯ä¸Šã«ã‚ã‚‹ & è¶³å…ƒãŒåœ°é¢ã«è¿‘ã„ï¼‰
      const overByRear = rearX >= blockScreenLeft - 5 && rearX <= blockScreenRight + 5;
      const overByFront = playerRight >= blockScreenLeft - 5 && playerRight <= blockScreenRight + 5;

      if (velY >= 0 && (overByRear || overByFront)) {
        // æ®µå·®è¨±å®¹ï¼šè¶³å…ƒãŒãƒ–ãƒ­ãƒƒã‚¯å¤©é¢ã‹ã‚‰Â±LAND_MARGINä»¥å†…ãªã‚‰ã€Œä¹—ã‚Šä¸Šã’ï¼ˆç€åœ°ï¼‰ã€ã¨ã—ã¦æ‰±ã†
        if (playerFeetY >= blockTop - LAND_MARGIN && playerFeetY <= blockTop + LAND_MARGIN) {
          playerY = blockTop - PLAYER_HEIGHT;
          velY = 0;
          if (!onGround) {
            onGround = true;
            canDoubleJump = true;
            usedDoubleJump = false;
            if (!wasGroundedBefore && !landedThisFrame && state === 'playing') {
              initAudioContext();
              playLandSound();
              landedThisFrame = true;
            }
          } else {
            onGround = true;
            canDoubleJump = true;
            usedDoubleJump = false;
          }
        }
      }
    }

    // 3. è½ä¸‹æ­»ï¼ˆç©´ã«è½ã¡ã‚‹ï¼‰ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç”»é¢ä¸‹ç«¯ã‹ã‚‰å®Œå…¨ã«æ¶ˆãˆãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼ˆCH + 150ï¼‰
    if (playerY > CH + 150) {
      if (state === 'playing') {
        initAudioContext();
        playHitSound();
      }
      state = 'gameover';
    }
  }

  function update(dt) {
    if (state !== 'playing') return;
    scrollSpeed = Math.min(MAX_SPEED, BASE_SPEED + distance * SPEED_INCREASE_PER_M);
    worldOffset += scrollSpeed;
    distance += scrollSpeed * (dt / 1000) * 3;
    generateTerrain();
    removeOffscreenTerrain();
    updatePlayer(dt);
  }

  function drawBgStars() {
    const canvas = document.getElementById('bgStarsCanvas');
    if (!canvas) return;
    const w = window.innerWidth || 800;
    const h = window.innerHeight || 600;
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      bgCanvasWidth = w;
      bgCanvasHeight = h;
      bgCtx = canvas.getContext('2d');
      bgStars = [];
      bgClouds = [];
    }
    if (!bgCtx) return;
    const hour = new Date().getHours();
    const isDaytime = hour >= 6 && hour < 18;
    const skyLine = h * 0.55;

    if (isDaytime) {
      // æ˜¼: ç©ºã€œåœ°å¹³ã€œé æ™¯ã‚’1æœ¬ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã§ç¹‹ãã€ç¡¬ã„å¢ƒç•Œã‚’å‡ºã•ãªã„
      const dayGrad = bgCtx.createLinearGradient(0, 0, 0, h);
      dayGrad.addColorStop(0, '#4A90E2');
      dayGrad.addColorStop(0.35, '#6BB0F7');
      dayGrad.addColorStop(0.55, '#87CEFA');
      dayGrad.addColorStop(0.62, '#C8E4E8');
      dayGrad.addColorStop(0.7, '#7a9a6e');
      dayGrad.addColorStop(0.82, '#4a5d3a');
      dayGrad.addColorStop(0.92, '#2d3825');
      dayGrad.addColorStop(1, '#1a2018');
      bgCtx.fillStyle = dayGrad;
      bgCtx.fillRect(0, 0, w, h);
      // å¤ªé™½ï¼ˆå³ä¸Šå¯„ã‚Šãƒ»ãƒ‘ãƒ©ãƒ©ãƒƒã‚¯ã‚¹ã§ã‚†ã£ãã‚Šå‹•ãï¼‰
      const sunX = w * 0.82 + (worldOffset * 0.02) % (w * 0.3);
      const sunY = h * 0.18;
      const sunR = Math.min(w, h) * 0.08;
      const glow = bgCtx.createRadialGradient(sunX, sunY, 0, sunX, sunY, sunR * 2.5);
      glow.addColorStop(0, 'rgba(255, 240, 180, 0.95)');
      glow.addColorStop(0.4, 'rgba(255, 220, 100, 0.6)');
      glow.addColorStop(0.7, 'rgba(255, 180, 60, 0.2)');
      glow.addColorStop(1, 'rgba(255, 150, 50, 0)');
      bgCtx.fillStyle = glow;
      bgCtx.beginPath();
      bgCtx.arc(sunX, sunY, sunR * 2.5, 0, Math.PI * 2);
      bgCtx.fill();
      bgCtx.fillStyle = '#FFE066';
      bgCtx.beginPath();
      bgCtx.arc(sunX, sunY, sunR, 0, Math.PI * 2);
      bgCtx.fill();
      // é›²ã®åˆæœŸåŒ–
      if (!bgClouds.length) {
        for (let i = 0; i < 6; i++) {
          bgClouds.push({
            x: Math.random() * w * 2,
            y: Math.random() * skyLine * 0.7,
            parallax: 0.15 + Math.random() * 0.25,
            size: 25 + Math.random() * 35
          });
        }
      }
      bgCtx.fillStyle = 'rgba(255, 255, 255, 0.75)';
      for (const c of bgClouds) {
        const cx = (c.x - worldOffset * 0.04 * c.parallax) % (w * 2.2);
        const sx = cx < 0 ? cx + w : cx;
        if (sx < -c.size * 3 || sx > w + c.size * 2) continue;
        const sy = c.y;
        const r = c.size;
        bgCtx.beginPath();
        bgCtx.arc(sx, sy, r * 0.9, 0, Math.PI * 2);
        bgCtx.arc(sx + r * 0.8, sy - r * 0.2, r * 0.7, 0, Math.PI * 2);
        bgCtx.arc(sx + r * 1.4, sy, r * 0.85, 0, Math.PI * 2);
        bgCtx.arc(sx + r * 0.5, sy + r * 0.3, r * 0.6, 0, Math.PI * 2);
        bgCtx.fill();
      }
    } else {
      // å¤œ: åœ°é¢ã‚ˆã‚Šä¸‹ã¯å¥ˆè½ï¼ˆé»’ï¼‰ã€ãã®ä¸Šã«æ˜Ÿç©º
      bgCtx.fillStyle = '#000000';
      bgCtx.fillRect(0, skyLine, w, h - skyLine);
      // æ—¢å­˜ã®æ˜Ÿç©º
      if (!bgStars.length) {
        for (let i = 0; i < 180; i++) {
          bgStars.push({
            x: Math.random() * w * 1.3,
            y: Math.random() * skyLine,
            r: Math.random() * 1.2 + 0.2,
            parallax: 0.3 + Math.random() * 0.7
          });
        }
        for (let i = 0; i < 220; i++) {
          bgStars.push({
            x: Math.random() * w * 1.5,
            y: Math.random() * (skyLine * 0.9),
            r: Math.random() * 1.0 + 0.15,
            parallax: 0.2 + Math.random() * 0.5
          });
        }
      }
      const grad = bgCtx.createLinearGradient(0, 0, 0, skyLine);
      grad.addColorStop(0, '#050818');
      grad.addColorStop(0.35, '#0d1530');
      grad.addColorStop(0.7, '#1a1b3b');
      grad.addColorStop(1, '#020008');
      bgCtx.fillStyle = grad;
      bgCtx.fillRect(0, 0, w, skyLine);
      bgCtx.fillStyle = '#e8eeff';
      for (const s of bgStars) {
        if (s.y >= skyLine) continue;
        const offsetX = (s.x - worldOffset * 0.06 * s.parallax) % (w * 1.5);
        const sx = offsetX < 0 ? offsetX + w : offsetX;
        if (sx >= w) continue;
        bgCtx.beginPath();
        bgCtx.arc(sx, s.y, s.r, 0, Math.PI * 2);
        const alpha = 0.5 + 0.4 * Math.sin((worldOffset * 0.002 + s.x) * 0.3);
        bgCtx.globalAlpha = Math.min(1, alpha + 0.1);
        bgCtx.fill();
        bgCtx.globalAlpha = 1;
      }
    }
  }

  function draw() {
    // ãƒ—ãƒ¬ã‚¤ä¸­ãƒ»ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã¯å…¨ç”»é¢ã«ç©ºã‚’æç”»ï¼ˆç«¯æœ«æ™‚åˆ»ã§æ˜¼=é’ç©º/å¤ªé™½/é›²ã€å¤œ=æ˜Ÿç©ºï¼‰
    if (state === 'playing' || state === 'gameover') {
      drawBgStars();
    } else if (bgCtx && bgCanvasWidth && bgCanvasHeight) {
      bgCtx.clearRect(0, 0, bgCanvasWidth, bgCanvasHeight);
    }
    // Canvas ã®ç©ºéƒ¨åˆ†ã¯é€æ˜ï¼ˆå¤–å´ã®å…¨ç”»é¢èƒŒæ™¯ãŒé€ã‘ã¦1ã¤ã®ç©ºã«ï¼‰
    ctx.clearRect(0, 0, CW, CH);
    const hour = new Date().getHours();
    const isDaytime = hour >= 6 && hour < 18;

    if (isDaytime) {
      // æ˜¼: å¥ˆè½ã¯æã‹ãšã€é æ™¯ã®ã¿ï¼ˆç©ºã¯å¤–å´ã®å…¨ç”»é¢ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã«ä»»ã›ã‚‹ï¼‰
      const horizonY = GROUND_Y_BASE - 40;
      const hGrad = ctx.createLinearGradient(0, horizonY, 0, CH);
      hGrad.addColorStop(0, 'rgba(122, 154, 110, 0.35)');
      hGrad.addColorStop(0.2, 'rgba(74, 93, 58, 0.75)');
      hGrad.addColorStop(0.5, '#4a5d3a');
      hGrad.addColorStop(0.8, '#2d3825');
      hGrad.addColorStop(1, '#1a2018');
      ctx.fillStyle = hGrad;
      ctx.fillRect(0, horizonY, CW, CH - horizonY);
      // é æ™¯ã®å±±ä¸¦ã¿ï¼ˆãªã ã‚‰ã‹ãªç°ç·‘ã®é€£å³°ï¼‰
      ctx.fillStyle = 'rgba(61, 74, 53, 0.9)';
      ctx.beginPath();
      ctx.moveTo(0, CH);
      ctx.lineTo(0, GROUND_Y_BASE + 30);
      ctx.lineTo(CW * 0.2, GROUND_Y_BASE - 20);
      ctx.lineTo(CW * 0.45, GROUND_Y_BASE + 10);
      ctx.lineTo(CW * 0.7, GROUND_Y_BASE - 35);
      ctx.lineTo(CW * 1.1, GROUND_Y_BASE + 40);
      ctx.lineTo(CW * 1.1, CH);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = 'rgba(53, 64, 42, 0.85)';
      ctx.beginPath();
      ctx.moveTo(0, CH);
      ctx.lineTo(CW * 0.35, GROUND_Y_BASE);
      ctx.lineTo(CW * 0.6, GROUND_Y_BASE - 25);
      ctx.lineTo(CW * 0.9, GROUND_Y_BASE + 20);
      ctx.lineTo(CW * 1.2, CH);
      ctx.closePath();
      ctx.fill();
    } else {
      // å¤œ: åœ°é¢ã‚ˆã‚Šä¸‹ã¯ç´”é»’ã®å¥ˆè½
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, GROUND_Y_BASE, CW, CH - GROUND_Y_BASE);
    }

    // åœ°é¢ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆæ˜¼ã¯ãƒ•ãƒ©ãƒƒãƒˆé“è·¯ï¼‹ç´«ãƒã‚ªãƒ³ç¸ã€å¤œã¯ãƒã‚ªãƒ³ç¸å–ã‚Šï¼‰
    for (const block of terrain) {
      const sx = block.x - worldOffset;
      if (sx + block.w < 0) continue;
      const drawW = block.w + 1;
      if (isDaytime) {
        ctx.fillStyle = '#808080';
        ctx.fillRect(sx, block.y, drawW, block.h);
        ctx.shadowColor = '#d891ff';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = '#9b5bff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(sx, block.y + 0.5);
        ctx.lineTo(sx + drawW, block.y + 0.5);
        ctx.stroke();
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      } else {
        ctx.fillStyle = '#06051b';
        ctx.fillRect(sx, block.y, drawW, block.h);
        ctx.strokeStyle = '#9b5bff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(sx, block.y + 0.5);
        ctx.lineTo(sx + drawW, block.y + 0.5);
        ctx.stroke();
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç”»åƒ or ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    const px = PLAYER_WORLD_X;
    const drawX = px - PLAYER_WIDTH / 2 + PLAYER_DRAW_OFFSET_X;
    const drawY = playerY + PLAYER_DRAW_OFFSET_Y;
    if (isDaytime) {
      ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
      ctx.shadowBlur = 10;
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 4;
    }
    if (playerImgLoaded) {
      ctx.drawImage(playerImage, drawX, drawY, PLAYER_WIDTH, PLAYER_HEIGHT);
    } else {
      ctx.fillStyle = '#e94560';
      ctx.strokeStyle = '#ff6b6b';
      ctx.lineWidth = 2;
      ctx.fillRect(drawX, drawY, PLAYER_WIDTH, PLAYER_HEIGHT);
      ctx.strokeRect(drawX, drawY, PLAYER_WIDTH, PLAYER_HEIGHT);
      ctx.fillStyle = '#1a1a2e';
      ctx.font = '14px sans-serif';
      ctx.fillText('BIKE', drawX + PLAYER_WIDTH / 2 - 18, drawY + PLAYER_HEIGHT / 2 + 4);
    }
    if (isDaytime) {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;
    }

    if (state === 'playing') {
      scoreEl.textContent = Math.floor(distance) + ' m';
    }

    if (state === 'gameover') {
      scoreEl.style.display = 'none';
      gameOverScreen.style.display = 'flex';
      const shownScore = Math.floor(distance);
      finalScoreEl.innerHTML = shownScore + ' <span>m</span>';
      if (!hasShownGameOver) {
        hasShownGameOver = true;
        const isNewRecord = updateBestScoreIfNeeded(shownScore);
        if (newRecordLabelEl) {
          newRecordLabelEl.style.display = isNewRecord ? 'block' : 'none';
        }
        submitScoreAndLoadRanking();
      }
    } else {
      hasShownGameOver = false;
      if (newRecordLabelEl) newRecordLabelEl.style.display = 'none';
    }
  }

  function gameLoop(t) {
    const dt = Math.min(t - lastTime, 50);
    lastTime = t;
    update(dt);
    draw();
    requestAnimationFrame(gameLoop);
  }

  const startBtnEl = document.getElementById('startBtn');
  if (startBtnEl) {
    startBtnEl.addEventListener('click', function() {
      initAudioContext();
      if (audioCtx && !jumpBuffer && !jumpBufferLoading) {
        loadJumpSoundBuffer();
      }
      startGameWithTransition();
    });
  }
  const retryBtnEl = document.getElementById('retryBtn');
  if (retryBtnEl) {
    retryBtnEl.addEventListener('click', function() {
      initGame();
    });
  }
  if (backToTitleBtn) {
    backToTitleBtn.addEventListener('click', function() {
      resetToTitle();
    });
  }

  // ãƒ‹ãƒƒã‚¯ãƒãƒ¼ãƒ å…¥åŠ› åˆæœŸåŒ–
  if (nicknameInput) {
    loadNickname();
    nicknameInput.addEventListener('input', function() {
      currentNickname = nicknameInput.value.trim();
      if (nicknameError) nicknameError.textContent = '';
    });
  }

  if (rankTabs && rankTabs.length) {
    rankTabs.forEach(btn => {
      btn.addEventListener('click', function() {
        const range = btn.getAttribute('data-rank-range') || 'today';
        loadRanking(range);
      });
    });
  }

  loadBestScore();
  // åˆå›è¡¨ç¤ºæ™‚ã«ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’èª­ã¿è¾¼ã‚€
  loadRanking(currentRankRange || 'today');

  function isUiElement(target) {
    if (!target || !target.closest) return false;
    return !!target.closest('button, a, input, textarea, select, label, .rank-tab, .rank-list');
  }

  function handlePrimaryDown(e) {
    const target = e.target;
    if (isUiElement(target)) return;
    if (e.type === 'touchstart') {
      e.preventDefault();
    }
    if (state === 'playing') {
      jump();
    }
  }

  document.addEventListener('touchstart', handlePrimaryDown, { passive: false });
  document.addEventListener('mousedown', handlePrimaryDown);

  document.addEventListener('keydown', function(e) {
    if (e.code === 'Space') {
      if (spaceHeld) return;         // æŠ¼ã—ã£ã±ãªã—ä¸­ã¯ç„¡è¦–
      spaceHeld = true;
      e.preventDefault();
      if (state === 'start') {
        startGameWithTransition();
      } else if (state === 'playing') {
        jump();
      }
      return;
    }
    if (e.code === 'KeyR' && state === 'gameover') {
      e.preventDefault();
      initGame();
    }
  });

  document.addEventListener('keyup', function(e) {
    if (e.code === 'Space') {
      spaceHeld = false;
    }
  });

  // é–‹å§‹ç”»é¢ã§ã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«å¯èƒ½ã«ã€‚ã‚²ãƒ¼ãƒ å®Ÿè¡Œä¸­ã®ã¿ gesture/contextmenu ã‚’æŠ‘åˆ¶
  function preventGameGestures(e) {
    const target = e.target;
    // 1. ãƒ©ãƒ³ã‚­ãƒ³ã‚°ãƒªã‚¹ãƒˆå†…ã§ã®æ“ä½œãªã‚‰ã€ãƒ–ãƒ©ã‚¦ã‚¶ã«ä»»ã›ã‚‹ï¼ˆã“ã“ã§çµ‚äº†ï¼‰
    if (target && target.closest && target.closest('.rank-list')) {
      return;
    }
    // 2. ãã‚Œä»¥å¤–ã®å ´æ‰€ï¼ˆèƒŒæ™¯ãªã©ï¼‰ã§ã®ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œã¯ã€å³åº§ã«ã€Œç¦æ­¢ã€ã™ã‚‹
    if (e.type === 'touchmove') {
      e.preventDefault();
      return;
    }
    // 3. ãã®ä»–ï¼ˆã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼ã‚„å³ã‚¯ãƒªãƒƒã‚¯æŠ‘åˆ¶ï¼‰ã®å‡¦ç†
    if (state !== 'playing') return;
    if (target && target.closest && target.closest('.rank-tab')) return;
    if (target && target.closest && target.closest('#gameContainer')) e.preventDefault();
  }
  document.addEventListener('touchmove', preventGameGestures, { passive: false });
  document.addEventListener('gesturestart', preventGameGestures);
  document.addEventListener('gesturechange', preventGameGestures);
  document.addEventListener('gestureend', preventGameGestures);
  document.addEventListener('contextmenu', preventGameGestures);

  // â†“ ã“ã“ã«ã‚ã£ãŸ git add . ã‚’æ¶ˆã—ã¾ã—ãŸ
  requestAnimationFrame(gameLoop);
})();
  </script>
</body>
</html>
